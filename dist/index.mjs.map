{"version":3,"sources":["../src/maybe/nothing.ts","../src/maybe/just.ts","../src/maybe/maybe-imp.ts"],"names":["Nothing","_","nothing","defaultValue","callbackDefaultLazy","initialType","effect","Just","_value","callbackMap","result","just","aValue","pred","callbackChain","aNewMonad","aMonad","reducer","value","MaybeImp"],"mappings":"AAWO,IAAMA,EAAN,KAAwC,CACtC,QAAkB,CACvB,MAAO,EACT,CAEO,WAA6B,CAClC,MAAO,EACT,CAEO,IACLC,EACwB,CACxB,OAAOC,EAAQ,CACjB,CAEO,MACLD,EACwB,CACxB,OAAOC,EAAQ,CACjB,CAEO,OAAaD,EAAuB,CACzC,OAAOC,EAAQ,CACjB,CAEO,UAAuBC,EAAwC,CACpE,OAAOA,CACT,CAEO,cACLC,EACa,CACb,OAAOA,EAAoB,CAC7B,CAEO,SAAgC,CACrC,MAAO,CACL,QAAS,EACX,CACF,CAEO,OACLH,EACAI,EACiB,CACjB,OAAOA,CACT,CAEO,OAAOJ,EAAgB,CAC5B,OAAO,IACT,CAEA,UAAUK,EAAqC,CAC7C,OAAAA,EAAO,EACA,IACT,CACF,EAEO,SAASJ,GAAmB,CACjC,OAAO,IAAIF,CACb,CC7DO,IAAMO,EAAN,KAAwC,CAC7C,YAAoBC,EAAc,CAAd,YAAAA,CAAe,CAEnC,QAA6B,CAC3B,MAAO,EACT,CAEA,IAAY,OAAQ,CAClB,OAAO,KAAK,MACd,CAEO,WAAqB,CAC1B,MAAO,EACT,CAEO,IACLC,EACwB,CACxB,IAAMC,EAASD,EAAY,KAAK,MAAM,EACtC,OAAO,KAAK,QAAQC,CAAM,EAAIR,EAAQ,EAAIS,EAAKD,CAAM,CACvD,CAEQ,QAAQE,EAA6C,CAC3D,OAA+BA,GAAW,IAC5C,CAEO,OACLC,EACiB,CACjB,OAAOA,EAAK,KAAK,KAAK,EAAIF,EAAK,KAAK,KAAK,EAAIT,EAAQ,CACvD,CAEO,MACLY,EACwB,CACxB,IAAMC,EAAYD,EAAc,KAAK,MAAM,EAC3C,OAAO,KAAK,kBAAkBC,CAAS,EAAIb,EAAQ,EAAIa,CACzD,CAEQ,kBACNC,EACS,CACT,IAAMN,EAASM,EAAO,QAAQ,EAC9B,OAAON,EAAO,SAAW,KAAK,QAAQA,EAAO,IAAI,CACnD,CAEO,UAAUT,EAAe,CAC9B,OAAO,KAAK,MACd,CAEO,cAAcA,EAAgB,CACnC,OAAO,KAAK,MACd,CAEO,SAA+B,CACpC,MAAO,CACL,QAAS,GACT,KAAM,KAAK,KACb,CACF,CAEO,OACLgB,EACAZ,EACiB,CACjB,OAAOY,EAAQZ,EAAa,KAAK,MAAM,CACzC,CAEO,OAAOC,EAAoC,CAChD,OAAAA,EAAO,KAAK,MAAM,EACX,IACT,CAEO,UAAUL,EAAgB,CAC/B,OAAO,IACT,CACF,EAEO,SAASU,EAAWO,EAA0B,CACnD,OAAO,IAAIX,EAAKW,CAAK,CACvB,CCtFA,IAAqBC,EAArB,KAA8B,CAC5B,OAAc,GAASD,EAA0B,CAC/C,OAAOP,EAAWO,CAAK,CACzB,CAEA,OAAc,OAA2B,CACvC,OAAOhB,EAAQ,CACjB,CACF","sourcesContent":["import { Just } from './just'\nimport type {\n  Callback,\n  CallbackChain,\n  CallbackDefaultLazy,\n  CallbackEffect,\n  CallbackEffectNothing,\n  GetSafeReturn,\n  Maybe,\n} from './maybe'\n\nexport class Nothing implements Maybe<Nothing> {\n  public isJust(): boolean {\n    return false\n  }\n\n  public isNothing(): this is Nothing {\n    return true\n  }\n\n  public map<TransformedType>(\n    _: Callback<never, TransformedType>,\n  ): Maybe<TransformedType> {\n    return nothing()\n  }\n\n  public chain<TransformedType>(\n    _: CallbackChain<never, TransformedType>,\n  ): Maybe<TransformedType> {\n    return nothing()\n  }\n\n  public filter<Type>(_: never): Maybe<Type> {\n    return nothing()\n  }\n\n  public orDefault<DefaultType>(defaultValue: DefaultType): DefaultType {\n    return defaultValue\n  }\n\n  public orDefaultLazy<DefaultType>(\n    callbackDefaultLazy: CallbackDefaultLazy<DefaultType>,\n  ): DefaultType {\n    return callbackDefaultLazy()\n  }\n\n  public getSafe(): GetSafeReturn<never> {\n    return {\n      success: false,\n    }\n  }\n\n  public reduce<TransformedType = Nothing>(\n    _: never,\n    initialType: TransformedType,\n  ): TransformedType {\n    return initialType\n  }\n\n  public ifJust(_: never): this {\n    return this\n  }\n\n  ifNothing(effect: CallbackEffectNothing): this {\n    effect()\n    return this\n  }\n}\n\nexport function nothing(): Nothing {\n  return new Nothing()\n}\n","import type {\n  Callback,\n  CallbackChain,\n  CallbackEffect,\n  CallbackPredicate,\n  GetSafeReturn,\n  Maybe,\n} from './maybe'\nimport { nothing } from './nothing'\n\nexport class Just<Type> implements Maybe<Type> {\n  constructor(private _value: Type) {}\n\n  isJust(): this is Just<Type> {\n    return true\n  }\n\n  private get value() {\n    return this._value\n  }\n\n  public isNothing(): boolean {\n    return false\n  }\n\n  public map<TransformedType>(\n    callbackMap: Callback<Type, TransformedType>,\n  ): Maybe<TransformedType> {\n    const result = callbackMap(this._value)\n    return this.isEmpty(result) ? nothing() : just(result)\n  }\n\n  private isEmpty(aValue: unknown): aValue is null | undefined {\n    return aValue === undefined || aValue === null\n  }\n\n  public filter<NextType extends Type>(\n    pred: CallbackPredicate<Type, NextType>,\n  ): Maybe<NextType> {\n    return pred(this.value) ? just(this.value) : nothing()\n  }\n\n  public chain<TransformedType>(\n    callbackChain: CallbackChain<Type, TransformedType>,\n  ): Maybe<TransformedType> {\n    const aNewMonad = callbackChain(this._value)\n    return this.isMonadValueEmpty(aNewMonad) ? nothing() : aNewMonad\n  }\n\n  private isMonadValueEmpty<TransformedType>(\n    aMonad: Maybe<TransformedType>,\n  ): boolean {\n    const result = aMonad.getSafe()\n    return result.success && this.isEmpty(result.data)\n  }\n\n  public orDefault(_: Type): Type {\n    return this._value\n  }\n\n  public orDefaultLazy(_: never): Type {\n    return this._value\n  }\n\n  public getSafe(): GetSafeReturn<Type> {\n    return {\n      success: true,\n      data: this.value,\n    }\n  }\n\n  public reduce<TransformedType = Type>(\n    reducer: (acc: TransformedType, item: Type) => TransformedType,\n    initialType: TransformedType,\n  ): TransformedType {\n    return reducer(initialType, this._value)\n  }\n\n  public ifJust(effect: CallbackEffect<Type>): this {\n    effect(this._value)\n    return this\n  }\n\n  public ifNothing(_: never): this {\n    return this\n  }\n}\n\nexport function just<Type>(value: Type): Maybe<Type> {\n  return new Just(value)\n}\n","import type { Maybe } from './maybe'\nimport { just } from './just'\nimport { nothing } from './nothing'\n\nexport default class MaybeImp {\n  public static of<Type>(value: Type): Maybe<Type> {\n    return just<Type>(value)\n  }\n\n  public static empty<Type>(): Maybe<Type> {\n    return nothing()\n  }\n}\n"]}